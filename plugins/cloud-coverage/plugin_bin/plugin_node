#!/usr/bin/python3
# ANL:waggle-license
#  This file is part of the Waggle Platform.  Please see the file
#  LICENSE.waggle.txt for the legal details of the copyright and software
#  license.  For more details on the Waggle project, visit:
#           http://www.wa8.gl
# ANL:waggle-license

import os
import time
import argparse
import cv2
import numpy as np
import sys

import joblib
from sklearn.cross_decomposition import PLSRegression

from waggle.pipeline import ImagePipelineHandler
import waggle.plugin
#from waggle.protocol.v5.encoder import encode_frame

np.seterr(divide='ignore', invalid='ignore')

def get_default_configuration():
    return {
        'source': 'top',
        'model': '/wagglerw/plugins/cloud-coverage.plugin/plugin_bin/models/swimseg_model_128.pkl',
        'input_scale': 0.00784,
        'input_size': (300, 300),
        'input_mean_subtraction': (127.5, 127.5, 127.5),
        'input_channel_order': 'RGB',
        'detection_interval': 300,  # every 5 mins
        'sampling_interval': -1,  # None, by default
        'detection_confidence': 0.5,  # least detection confidence
    }


class CloudEstimator():
    def __init__(self, plugin):
        self.plugin = plugin
        self.config = self._get_config_table()
        self.input_handler = ImagePipelineHandler(
            routing_in=self.config['source'])

        #self.hrf = False
        #self.input_handler = ImagePipelineHandler(routing_in=self.config['source'])
        #self.input_image_path = image_name

        def close(self):
            self.input_handler.close()

    def _get_config_table(self):
        try:
            return read_json_file('/wagglerw/waggle/cloud_coverage_estimator.conf')
        except Exception:
            return get_default_configuration()


    def _feature_generator(self, img):
        #Input_Image = img
        #Input_Image = cv2.imread('test_0ca.jpg')
        #Input_Image_RGB = cv2.cvtColor(Input_Image, cv2.COLOR_BGR2RGBA)
        #Input_Image_RGB = Input_Image

        Input_Image_RGB = img

        #Input_Image_HSV = cv2.cvtColor(Input_Image, cv2.COLOR_BGR2HSV)
        Input_Image_HSV = cv2.cvtColor(img, cv2.COLOR_RGB2HSV)

        Image_Array_RGB = np.array(Input_Image_RGB)
        Image_Array_HSV = np.array(Input_Image_HSV)

        Image_Shape = Image_Array_RGB.shape
        Pixels_Count = Image_Shape[0] * Image_Shape[1]

        Input_Image_Red = Image_Array_RGB[:,:,2]
        Input_Image_Blue = Image_Array_RGB[:, :, 0]

        Input_Image_Difference = Input_Image_Red / Input_Image_Blue * 100

        One_D_Image_Red = np.transpose(np.matrix(Image_Array_RGB[:, :, 2].ravel()))
        One_D_Image_Blue = np.transpose(np.matrix(Image_Array_RGB[:, :, 0].ravel()))

        One_D_Image_Red = One_D_Image_Red.astype(np.int16)
        One_D_Image_Blue = One_D_Image_Blue.astype(np.int16)

        One_D_Image_S = np.transpose(np.matrix(Image_Array_HSV[:, :, 1].ravel()))

        One_D_Image_Blue[One_D_Image_Blue == 0] = 1

        ratio = One_D_Image_Red / (One_D_Image_Blue)
        One_D_Image_RATIO = ratio
        ratio = np.reshape(ratio, (Image_Shape[0], Image_Shape[1]))
        img_ratio = np.array(ratio * 255, dtype=np.uint8)

        One_D_Image_DIFF = One_D_Image_Red - One_D_Image_Blue

        One_D_Image_NORMALIZED = ( One_D_Image_Blue - One_D_Image_Red ) / (One_D_Image_Blue + One_D_Image_Red)

        One_D_Image = np.hstack((One_D_Image_S, \
                    One_D_Image_RATIO, \
                    One_D_Image_NORMALIZED, \
                    ))

        return One_D_Image, Image_Shape

    def _soft_thresholding(self, labels):

        min_v = min(labels)
        max_v = max(labels)
        theta = ( labels - min_v ) / ( max_v - min_v )

        return theta

    def _threshold(self, input, target_shape, confidence):

        za = (np.asarray(input) < confidence).sum()
        percentage = (za / (target_shape[0] * target_shape[1])) * 100

        return percentage

    def _coverage_predictor(self, target_feature, model, target_shape):
        # reg_start = time.time()
        Y_pred = model.predict(target_feature)
        # reg_end = time.time()
        # print('inference time {}'.format(reg_end-reg_start))

        ## target_shape[0]: Width, target_shape[1]: Height
        predicted = np.reshape(Y_pred, (target_shape[0], target_shape[1]))
        predicted = np.array(predicted * 255, dtype = np.uint8)
        cv2.imwrite('predicted.jpg', predicted.T)

        return Y_pred

    def run(self):
        estimation = 0
        model = joblib.load(self.config['model'])
        #print('Loading model {}'.format(model))

        try:
            confidence = float(self.config['detection_confidence'])
        except Exception:
            confidence = 0.5

        self.config['last_updated'] = time.time() - self.config['detection_interval']
        self.config['last_sampled'] = time.time() - self.config['sampling_interval']

        if self.config['sampling_interval'] < 1:
            do_sampling = False
        else:
            do_sampling = True

        while True:
            current_time = time.time()

            if current_time - self.config['last_updated'] > 3:
                return_code, message = self.input_handler.read()
                #print('[return_code]: ', return_code)
                #print('Receive timeout', flush=True)

                if return_code is True:
                    #print(time.asctime())
                    #print('Received frame', flush=True)
                    properties, frame = message
                    metadata = properties.headers
                    nparr_img = np.fromstring(frame, np.uint8)
                    img = cv2.imdecode(nparr_img, cv2.IMREAD_COLOR)

                    cv2.imwrite('test_0ca.jpg', img)
                    
                    counter = 0
                    try:
                        target_feature, target_shape = self._feature_generator(img)
                        predict = self._coverage_predictor(target_feature, model, target_shape)
                        soft_thresholded = self._soft_thresholding(predict)
                        estimation = self._threshold(soft_thresholded, target_shape, confidence)


                        '''
                        ## feature extraction and soft threshold take most of time
                        st = time.time()
                        target_feature, target_shape = self._feature_generator(img)
                        et = time.time()
                        print('feature generator elapsed in %.6f' % (et-st))

                        st = time.time()
                        predict = self._coverage_predictor(target_feature, model, target_shape)
                        et = time.time()
                        print('predictor elapsed in %.6f' % (et-st))

                        st = time.time()
                        soft_thresholded = self._soft_thresholding(predict)
                        et = time.time()
                        print('soft threshold elapsed in %.6f' % (et-st))

                        st = time.time()
                        estimation = self._threshold(soft_thresholded, target_shape, confidence)
                        et = time.time()
                        print('threshold elapsed in %.6f' % (et-st))
                        '''


                    except (KeyboardInterrupt, Exception) as ex:
                        counter = counter + 1
                        print("Exception occurred, caught and continuing", str(ex))
                        pass

                    print('cloud coverage estimation result: {}%'.format(estimation))

                    self.plugin.add_measurement({
                        'sensor_id': 0x3002,
                        'parameter_id': 1,
                        'value': estimation,
                    })

                    self.plugin.publish_measurements()


                    # Sampling the result
                    if do_sampling:
                        if current_time - self.config['last_sampled'] > self.config['sampling_interval']:
                            result = {
                                'processing_software': os.path.basename(__file__),
                                'results': json.dumps(estimation)
                            }
                            properties.headers.update(result)
                            self.input_handler.write(
                                ROUTING_KEY_EXPORT,
                                frame,
                                properties.headers
                            )
                            self.config['last_sampled'] = current_time
                self.config['last_updated'] = current_time
            else:
                wait_time = current_time - self.config['last_updated']
                if wait_time > 0.1:
                    time.sleep(wait_time)

if __name__ == '__main__':
    # plugin = CloudEstimator.defaltConfig().run()
    parser = argparse.ArgumentParser()
    parser.add_argument('--debug', action='store_true')
    args = parser.parse_args()

    if args.debug:
        plugin = waggle.plugin.PrintPlugin()
    else:
        plugin = waggle.plugin.Plugin()


    cce = CloudEstimator(plugin)
    cce.run()
        
